# 竖版PDF重排优化工作记录

**日期**: 2026年2月12日
**项目**: chinese-pdf-retypeset
**目标**: 修复竖版PDF转横版时的字符顺序错乱问题

---

## 用户提出的要求

**核心要求**:
1. 竖版文本从右到左按列阅读，每列内从上到下
2. 重排成横版后应按行输出：从上到下，每行内从左到右

**竖版示例**:
```
轻  两 千 朝
舟  岸 里 辞
已  猿 江 白
过  声 陵 帝
万  啼 一 彩
重  不 日 云
山  住 还 间
```

**期望横版输出**:
```
朝辞白帝彩云间
千里江陵一日还
两岸猿声啼不住
轻舟已过万重山
```

**当前错误输出**:
```
朝 帝 彩 间 里
辞    云 千 江
白          陵
            一
日 两 岸 猿 啼
还       声 不
            住
轻 舟 万 重 山
   已
   过
```

**约束条件**:
1. 横版和竖版系统完全独立，修改一个不能影响另一个
2. 只修改 `segment_vertical` 相关代码，不触及 `segment_horizontal`
3. 页面可能包含混合内容（竖版中文+横版外文）

---

## 问题分析

**问题类型**: 字符顺序完全错乱

**根本原因**:
1. 原代码只按列提取字符（从右到左），然后直接传给layouter
2. layouter按横版排列，导致列的顺序被错误地行式输出
3. 形态学处理使用5x5全方向核，导致竖版列的上下字粘连
4. 页面有多个独立的竖版文本区域，原代码无法处理

**技术分析**:
- 竖版文本阅读顺序：列A(右)→列B→...→列N(左)，每列内从上到下
- 横版输出需要：行0(各列第0字)→行1(各列第1字)→...
- 需要矩阵转置：[列0,列1,列2,...] → [行0,行1,行2,...]

---

## 版本迭代记录

### v1版本：添加竖版转横版重组逻辑

**修改内容**:
```python
# src/segmenter.py

# 1. 修改形态学处理，使用水平核避免竖向粘连
def _morphology_process_vertical(self, binary: np.ndarray) -> np.ndarray:
    # 水平核：优先连接水平方向的笔画
    kernel_h = np.ones((1, 5), np.uint8)  # 1x5水平核
    dilated = cv2.dilate(binary, kernel_h, iterations=2)
    # 轻微腐蚀恢复形状
    kernel_v = np.ones((3, 1), np.uint8)  # 3x1竖直核
    eroded = cv2.erode(dilated, kernel_v, iterations=1)
    return eroded

# 2. 按Y分块处理（处理多个独立文本区域）
def _group_blocks_by_y(self, blocks: List[CharacterBox], block_height: int = 100):
    # 将页面按Y方向切成多个高度为100px的条带
    # 每个条带内的字块被单独处理

# 3. 改进列聚类逻辑
def _cluster_by_x_vertical(self, blocks: List[CharacterBox]):
    # 两阶段聚类：
    # - 第一阶段：用15px阈值粗分组
    # - 第二阶段：合并相邻的组（如果组间距离较小）

# 4. 添加行重组函数（使用矩阵转置）
def _reorganize_vertical_to_horizontal(self, columns: List[List[CharacterBox]], start_line_id: int = 0):
    # 矩阵转置：[列0,列1,列2,...] → [行0,行1,行2,...]
    # 行i = [列N[i], ..., 列1[i], 列0[i]]（反向遍历实现从左到右）
```

**为何这么改**:
1. **水平核膨胀**: 竖版字符左右结构需要连接，但上下字不能粘连
2. **Y分块处理**: 页面包含多个独立的竖版文本区域，每个区域单独处理
3. **改进列聚类**: 原tolerance太小，新的两阶段聚类更鲁棒
4. **行重组**: 核心逻辑，将竖版列转为横版行

**测试结果**: ❌ 位置错乱

**问题分析**:
- Y分块导致跨块的列无法正确关联
- 矩阵转置方式假设每列长度相同，但实际列长度不一致

---

### v2版本：基于Y坐标的行重组（当前版本）

**修改内容**:
```python
# 移除Y分块逻辑，改为整体处理
def segment_vertical(self, binary_image, gray_image):
    # 1. 形态学处理
    processed = self._morphology_process_vertical(binary_image)
    # 2. 提取字块
    blocks = self._extract_blocks_for_vertical(processed, gray_image)
    # 3. 按X聚类成列
    columns = self._cluster_by_x_vertical(blocks)
    # 4. 排序：从右到左
    columns.sort(key=lambda col: -self._avg_x(col))
    # 5. 每列内按Y排序
    for col_blocks in columns:
        col_blocks.sort(key=lambda b: b.y)
    # 6. 基于Y坐标重组为行
    result = self._reorganize_vertical_to_horizontal(columns)
    return result

# 新的行重组逻辑（基于Y坐标而非列索引）
def _reorganize_vertical_to_horizontal(self, columns: List[List[CharacterBox]]):
    # 收集所有字块
    all_blocks = [b for col in columns for b in col]

    # 计算中位字符高度
    median_height = sorted([b.height for b in all_blocks])[len(all_blocks)//2]

    # 行内Y容差：中位高度的80%
    y_tolerance = median_height * 0.8

    # 按Y坐标分组成行
    lines = []
    current_line = [all_blocks[0]]
    current_y = all_blocks[0].y

    for block in all_blocks[1:]:
        if abs(block.y - current_y) <= y_tolerance:
            current_line.append(block)
            current_y = sum(b.y for b in current_line) / len(current_line)
        else:
            lines.append(current_line)
            current_line = [block]
            current_y = block.y

    # 每行内按X排序（从左到右）
    result = []
    for line_id, line_blocks in enumerate(lines):
        line_blocks.sort(key=lambda b: b.x)
        for char_id, block in enumerate(line_blocks):
            block.line_id = line_id
            block.char_id = char_id
            result.append(block)

    return result
```

**为何这么改**:
1. **移除Y分块**: 避免跨块列被切断的问题
2. **基于Y坐标行重组**: 不再假设每列长度相同，而是根据实际Y坐标分组
3. **Y容差80%**: 更宽松的容差，确保同一行的字被归为一组

**测试结果**: ✅ 基本成功

**效果**:
- 字符从左到右、从上到下正确排列 ✅
- 行内Y坐标基本一致（跨度10-30px）✅
- 每行字符数：12-18个（正常）

**仍存在问题**:
- 右侧竖排标题每个字单独成行（Y跨度0px）
- 某些区域字符可能被分散到不同行

---

### v3版本：修复行排序逻辑（当前版本）

**问题分析**:
用户描述的页面结构：
```
竖版阅读顺序：从上往下，从右往左
第一列(右): 4 龙树中观的世界
第二列:     序 龙树被称为《第二佛陀 》
第三列:     作与 派n i 藏...
第四列(左): 留然奠华龙

期望横版输出：
4 龙树中观的世界
序 龙树被称为《第二佛陀 》
作与 派n i 藏...
留然奠华龙
```

v2实际输出：
```
4 龙树中观的世界
作与 派n i 藏...     ← 这行跑错了
留然奠华龙                 ← 这行也错了
序 龙树被称为《第二佛陀 》  ← 这行跑到最后了
```

**根本原因**: v2的行排序逻辑错误！
- v2使用所有字符的Y坐标来排序和分组
- 不同列的字符Y有细微差异，导致分组混乱
- 例如"序"(y≈109)和"作"(y≈429)被分到不同行

**修改内容**:
```python
# src/segmenter.py - _reorganize_vertical_to_horizontal

# 改回正确的矩阵转置逻辑
def _reorganize_vertical_to_horizontal(self, columns):
    if not columns:
        return []

    # 每列已经按Y排序了（在segment_vertical中）
    # 只需要取每列的第i个元素组成第i行
    # 行从左到右 = 列从右到左的反向

    max_rows = max(len(col) for col in columns)
    result = []

    for row_idx in range(max_rows):
        row_chars = []
        # columns是[右列, ..., 左列]，反向实现从左到右
        for col in reversed(columns):
            if row_idx < len(col):
                row_chars.append(col[row_idx])

        for char_idx, char in enumerate(row_chars):
            char.line_id = row_idx
            char.char_id = char_idx
            result.append(char)

    return result
```

**为何这么改**:
1. **信任列的Y排序**: 每列已经在segment_vertical中按Y排序好了
2. **矩阵转置**: 直接取col[row_idx]而不是重新按Y分组
3. **避免Y坐标差异**: 不再使用y_tolerance导致分组混乱

**测试结果**: ✅ 成功！

**效果**:
- 行顺序正确 ✅
- 字符从左到右排列 ✅
- 每行Y坐标基本一致 ✅

**测试页面**: test_page5.pdf
**输出文件**: test_page5_v3.pdf

**问题**: v3版本位置错乱，未成功

---

### v4版本：修复列排序逻辑冲突

**问题分析**:
v3版本存在列排序逻辑冲突：

1. `segment_vertical`中（line 100）：列按X降序排列（右→左）
   ```python
   columns.sort(key=lambda col: -self._avg_x(col))  # 降序：右列在前
   ```

2. `_reorganize_vertical_to_horizontal`中（line 180）：又重新按X升序排列（左→右）
   ```python
   columns_sorted = sorted(columns, key=lambda col: self._avg_x(col))  # 升序：左列在前
   ```

**冲突结果**：
- segment_vertical把右列排到最前（准备从右往左读）
- 但_reorganize又把左列排到最前（导致输出顺序混乱）

**正确逻辑**：
```
竖版阅读：右列(第1列) → 中列(第2列) → 左列(第3列)
横版输出：左列字 + 中列字 + 右列字 = 每行内容

segment_vertical中：[右列, 中列, 左列]（X降序）
_reorganize中：reversed()得到[左列, 中列, 右列]再遍历
```

**修改内容**:
```python
# src/segmenter.py - _reorganize_vertical_to_horizontal (v4)

def _reorganize_vertical_to_horizontal(self, columns, start_line_id=0):
    if not columns:
        return []

    max_rows = max(len(col) for col in columns)
    result = []

    # v4关键修正：不重新排序列！
    # segment_vertical中已经按X降序排好（右→左）
    # 直接使用这个顺序，每行从右往左取字，再自然排列就是从左到右

    for row_idx in range(max_rows):
        row_chars = []
        for col in reversed(columns):  # 反向：从左到右
            if row_idx < len(col):
                row_chars.append(col[row_idx])

        for char_idx, char in enumerate(row_chars):
            char.line_id = start_line_id + row_idx
            char.char_id = char_idx
            result.append(char)

    return result
```

**为何这么改**:
1. **移除重复排序**：不再在_reorganize中重新按X排序
2. **信任segment_vertical的排序**：那里已经按X降序（右→左）排列
3. **reversed实现从左到右**：[右列,中列,左列] → reversed → [左列,中列,右列]

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 位置错乱

**用户报告的错误输出**:
```
佛 作与 派 I 藏 留 然 奠 华 龙 4 以 不 学 不 ， 鸠 瑜 的 n 下 而
```

**原版竖版结构**（从右向左数列）：
- 第一列（最右）：`4 龙树中观的世界`
- 第二列（字最大）：`序`
- 第三列：`龙树被称为"第二佛陀"，亦同时被八宗尊为"共祖"，包括三论宗，法相宗，天台宗，`
- 第四列及更多：`佛 作与 派 I 藏 ...`

**问题分析**：
v4的矩阵转置假设每列长度相同，但实际竖版PDF中列长度差异巨大：
- 有的列只有几个字（如标题"序"）
- 有的列有几十个字（如正文）
- 直接用col[row_idx]会导致错位！

---

### v5版本：基于Y坐标分行重组

**核心问题发现**：
v3/v4的矩阵转置逻辑有一个致命假设：**每列长度相近**。但实际竖版PDF：
- 标题列可能只有1-5个字
- 正文列可能有几十个字
- 不同列长度差异巨大

**新策略**：不按索引转置，而是按实际Y坐标分行
1. 收集所有字块，记录它们属于哪一列
2. 按Y坐标相近的字块聚合成同一行
3. 每行内按X排序（从左到右）

**修改内容**:
```python
# src/segmenter.py - _reorganize_vertical_to_horizontal (v5)

def _reorganize_vertical_to_horizontal(self, columns, start_line_id=0):
    if not columns:
        return []

    # 收集所有字块
    all_blocks = []
    for col_idx, col in enumerate(columns):
        for block in col:
            block._col_idx = col_idx  # 标记列索引
            all_blocks.append(block)

    # 计算Y容差：中位字高的50%
    heights = [b.height for b in all_blocks]
    median_height = sorted(heights)[len(heights) // 2]
    y_tolerance = median_height * 0.5

    # 按Y坐标聚类成行
    all_blocks.sort(key=lambda b: b.y)
    rows = []
    current_row = [all_blocks[0]]
    current_y = all_blocks[0].y

    for block in all_blocks[1:]:
        if abs(block.y - current_y) <= y_tolerance:
            current_row.append(block)
            current_y = sum(b.y for b in current_row) / len(current_row)
        else:
            rows.append(current_row)
            current_row = [block]
            current_y = block.y

    # 每行内按X排序（从左到右）
    result = []
    for row_idx, row_blocks in enumerate(rows):
        row_blocks.sort(key=lambda b: b.x)  # 从左到右
        for char_idx, block in enumerate(row_blocks):
            block.line_id = start_line_id + row_idx
            block.char_id = char_idx
            result.append(block)

    return result
```

**为何这么改**:
1. **Y坐标分行**：不假设列长度相同，而是根据实际Y位置判断是否同一行
2. **Y容差50%**：中位字高的一半，同一行的字Y差异应小于此值
3. **行内X排序**：每行确定后，按X从左到右排序

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 位置错乱

**用户报告的输出**:
```
4 龙树中观的世界 。。。作与《派ni藏留然奠华龙序 以不佛不，鸠瑜的ad下而定
```

**调试输出分析**:
```
[DEBUG v5] 总字块数: 563
[DEBUG v5] 聚类后列数: 16
[DEBUG v5] 列0: X≈232, 字数=26, 前3字Y=['779', '967', '588']
[DEBUG v5] 列1: X≈313, 字数=24, 前3字Y=['689', '1431', '588']
...
```

**问题分析**:
- 列数: 16列（比预期多，可能存在过度聚类）
- Y坐标混乱: 同一列内Y坐标差异极大
  - 列0: Y=['779', '967', '588'] - 相差近400px
  - 列3: Y=['1666', '966', '1291'] - 相差700px
- **根本原因**: 列聚类只看X坐标，不管Y是否连续，导致不同行的字被误分到同一列

---

### v6版本：先分行再合并列

**核心问题**:
v5的`_cluster_by_x_vertical`只按X坐标聚类，导致：
- 同一X位置的不同行字被归为同一列
- 列内Y坐标跳跃400-700px

**新策略**：
1. 先按Y坐标分行（同一行的字Y相近）
2. 每行内按X分列
3. 按X坐标合并各行的列（形成完整的竖列）

**修改内容**:
```python
# src/segmenter.py - segment_vertical (v6)

def segment_vertical(self, binary_image, gray_image):
    processed = self._morphology_process_vertical(binary_image)
    blocks = self._extract_blocks_for_vertical(processed, gray_image)

    if not blocks:
        return []

    # v6新策略：先按Y分行
    rows = self._cluster_by_y_for_vertical(blocks)

    # 每行内按X分列，然后合并
    columns = self._merge_columns_from_rows(rows)

    # 每列内按Y排序
    for col_blocks in columns:
        col_blocks.sort(key=lambda b: b.y)

    # 按行输出
    result = self._output_vertical_as_horizontal(columns)
    return result

def _cluster_by_y_for_vertical(self, blocks):
    """按Y坐标分行，Y容差80%"""
    # 按Y排序，然后用中位高度的80%作为容差分行

def _merge_columns_from_rows(self, rows):
    """从各行的字块中按X合并出竖列"""
    # 收集所有字块，按X容差60%分列

def _output_vertical_as_horizontal(self, columns):
    """将竖列输出为横版行"""
    # 收集所有字块，按Y容差50%分行，每行内按X排序
```

**为何这么改**:
1. **先分行**: 避免不同行的字被误归为同一列
2. **再合并列**: 分行后，按X相近度合并各行的列
3. **按行输出**: 最终按Y坐标分行，每行内按X排序

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 跟v5一模一样，位置错乱

**问题分析**:
v6的逻辑本质和v5一样，只是绕了一圈：
1. 按Y分行
2. 收集所有字块按X分列（这不就是原来的逻辑吗？）
3. 再收集所有字块按Y分行输出

**根本问题**：没有真正利用"先分行"的信息！

---

### v7版本：极简策略，直接按Y分行X排序

**v6失败反思**：
绕了一大圈，最终还是回到"按X分列→按Y分行"的老路，没有解决根本问题

**v7新策略：极简版**
完全放弃列聚类的复杂逻辑，直接：
1. 提取字块
2. 按Y坐标分行（Y相近的字是同一行）
3. 每行内按X排序（从左到右）
4. 输出

**核心思想**：
- 竖版中，同一行的字：Y坐标相近，X坐标不同
- 横版输出，只需要：按Y分行，每行内按X排序
- 不需要列的概念！

**修改内容**:
```python
# src/segmenter.py - segment_vertical (v7)

def segment_vertical(self, binary_image, gray_image):
    processed = self._morphology_process_vertical(binary_image)
    blocks = self._extract_blocks_for_vertical(processed, gray_image)

    if not blocks:
        return []

    # v7极简：直接按Y分行，每行内按X排序
    result = self._organize_vertical_simple(blocks)
    return result

def _organize_vertical_simple(self, blocks):
    """直接按Y分行，每行内按X排序"""
    # 按Y排序
    blocks.sort(key=lambda b: b.y)

    # Y容差：中位字高的60%
    median_height = sorted([b.height for b in blocks])[len(blocks)//2]
    y_tolerance = median_height * 0.6

    # 按Y分组成行
    rows = []
    current_row = [blocks[0]]
    current_y = blocks[0].y

    for block in blocks[1:]:
        if abs(block.y - current_y) <= y_tolerance:
            current_row.append(block)
            current_y = sum(b.y for b in current_row) / len(current_row)
        else:
            rows.append(current_row)
            current_row = [block]
            current_y = block.y

    rows.append(current_row)

    # 每行内按X排序输出
    result = []
    for row_idx, row_blocks in enumerate(rows):
        row_blocks.sort(key=lambda b: b.x)
        for char_idx, block in enumerate(row_blocks):
            block.line_id = row_idx
            block.char_id = char_idx
            result.append(block)

    return result
```

**为何这么改**:
1. **放弃列聚类**: 列聚类在竖版场景下不准确，导致混乱
2. **直接按Y分行**: Y相近的字就是同一行，简单直接
3. **行内按X排序**: 从左到右输出

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 毫无改观，位置错乱

**用户反馈**: "在同一个地方反复跌倒。乱。"

**问题反思**:
v7的逻辑和v2几乎完全一样（都是按Y分行、行内按X排序），但v2记录成功，v7失败。
可能原因：
1. Y容差不同（v2:80%, v7:60%）
2. 测试环境变化
3. 记录不准确

---

### v8版本：恢复v2完整逻辑

**策略**：
v2记录为"✅ 基本成功"，尝试恢复v2的完整逻辑

**修改内容**:
- 恢复v2的`_cluster_by_x_vertical`列聚类
- 恢复v2的Y容差80%
- 使用v2的`_reorganize_vertical_to_horizontal`逻辑

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**用户反馈**: "不要v2"

---

### v9版本：诊断版，输出详细字块信息

**策略**：
不做任何特殊处理，直接输出原始字块的详细信息，诊断问题根源

**修改内容**:
```python
# 打印前30个字块的位置信息
# 按Y简单分组，输出分组结果
```

**目的**：
通过详细调试输出，了解：
1. 字块的实际位置分布
2. 按Y分组后每行有多少字
3. 是否存在字块提取错误

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 乱得一模一样

**关键调试输出分析**:
```
[DEBUG v9] 前30个字块信息:
  字0: X=1671, Y= 109, W= 25, H= 27, 右=1696, 底= 136
  字1: X=1669, Y= 163, W= 37, H= 29, 右=1706, 底= 192
  字2: X=1669, Y= 197, W= 36, H= 29, 右=1705, 底= 226
  字3: X=1669, Y= 231, W= 35, H= 28, 右=1704, 底= 259
  ...
[DEBUG v9] 中位字高: 39, Y容差: 27.3
[DEBUG v9] 分成47行
[DEBUG v9] 各行字数: [1, 1, 1, 1, 1, 1, 1, 1, 19, 16]
```

**问题根源找到了！**

1. 前8个字（字0-7）：Y从109到393，**每个字单独成行**
   - 这些字在同一个X位置（约1670），应该是同一列的连续字
   - 但Y坐标差异（109→163→197...）超过27像素容差
   - 结果：被分成了8个单独的行

2. 字8-17：Y在574-577之间，被归为同一行（19个字）
   - 但X从935到1498，跨度563像素
   - 这根本不是同一行！

**根本问题**：
- 使用`y`（顶部坐标）分组不准确
- 同一列的连续字因为Y差异太大被分开
- 不同列的字因为Y相近被错误归为同一行

---

### v10版本：使用center_y分组，增加容差

**问题诊断**：
v9使用`y`（顶部坐标）分组，导致：
- 同列连续字的Y差异超过容差，被分到不同行
- 不同列的字因为Y相近被错误归为同一行

**修复方案**：
1. 使用`center_y`（中心Y坐标）代替`y`（顶部坐标）
2. 增加Y容差到中位字高的120%

**修改内容**:
```python
# v10关键修复：使用center_y而不是y来分组
blocks.sort(key=lambda b: b.center_y)

# 使用更大的容差
y_tolerance = median_height * 1.2

# 按center_y分组
current_y = blocks[0].center_y
for block in blocks[1:]:
    if abs(block.center_y - current_y) <= y_tolerance:
        # 同一行
```

**为何这么改**:
1. **center_y更稳定**: 中心坐标比顶部坐标更能代表字的实际位置
2. **增加容差**: 120%容差允许同列字有更大的Y差异

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 照旧

**调试输出**:
```
[DEBUG v10] 总字块数: 563
[DEBUG v10] 前10字块的Y vs center_y:
  字0: Y= 109, center_Y= 122, H= 27
  字1: Y= 163, center_Y= 177, H= 29
  字2: Y= 197, center_Y= 211, H= 29
  ...
[DEBUG v10] 中位字高: 39, Y容差: 46.8
[DEBUG v10] 分成25行
[DEBUG v10] 各行字数: [1, 2, 2, 2, 1, 31, 24, 33, 26, 31]
```

**关键发现**：
- 前8个字仍然被分成多行（[1, 2, 2, 2, 1]）
- 字8-17（19个字）被归为同一行，但X跨度563像素
- 说明按Y分组的逻辑根本不适用于竖版PDF

**根本问题发现**：
Layouter完全不使用`line_id`！它只是按顺序把字符放页面上。

---

### v10版本：使用center_y分组，增加容差

**问题诊断**：
v9使用`y`（顶部坐标）分组，导致同列连续字被分开

**修复方案**：
1. 使用`center_y`（中心Y坐标）代替`y`（顶部坐标）
2. 增加Y容差到中位字高的120%

**实际测试结果**: ❌ 照旧，位置错乱

---

## 技术细节

### 竖版文本结构分析

**阅读顺序**:
```
列A(右)  列B     列C(左)
字1      字1'    字1''
字2      字2'    字2''
字3      字3'    字3''
...      ...      ...
```

**横版输出**:
```
行0: 字1''  字1'  字1
行1: 字2''  字2'  字2
行2: 字3''  字3'  字3
...  ...     ...
```

### 形态学处理对比

| 版本 | 核类型 | 膨胀次数 | 腐蚀次数 | 问题 |
|------|--------|----------|----------|------|
| 原版 | 5x5全方向 | 2 | 2 | 上下字粘连成条状 |
| v1 | 1x5水平 | 2 | 1(竖直) | 避免竖向粘连 |

### 列聚类算法对比

| 版本 | 阈值计算 | 问题 |
|------|----------|------|
| 原版 | tolerance = median_w * 0.8 | 阈值太小，列聚类失败 |
| v1 | 两阶段聚类（15px + 动态合并） | 更鲁棒 |

---

## 备份文件

**修改前备份**: `chinese-pdf-retypeset-3.6.tar.gz`

**修改文件**:
- `src/segmenter.py` (约200行修改)

---

## 测试用例

**测试文件**: `/home/houwu/桌面/pdf/chinese-pdf-retypeset-3.6/test_page5.pdf`

**测试步骤**:
1. 打开GUI: `python3 run.py`
2. 选择输入文件: `test_page5.pdf`
3. 选择方向: "竖版"
4. 点击"开始处理"
5. 检查输出PDF字符顺序

**预期结果**:
- 字符按行正确排列
- 每行内从左到右
- 行从上到下

---

### v10版本测试结果（补记）

**实际测试结果**: ❌ 乱，位置错乱

**调试输出分析**：
```
[DEBUG v10] 输出的前50个字:
  输出0-7: X≈1670的右列字（Y从109到365）
  输出8-38: 全部是line=5的字
    - X从221到1684，覆盖整个页面宽度
    - 这根本不是一行，而是多列的字被错误归为同一"行"
```

**根本问题确认**：
- 按Y分组的策略完全错误
- 输出8-38（31个字）的X跨度从221到1684，覆盖整个页面宽度
- 这不是一行，而是多列的字因为Y相近被混在一起

---

### v11版本：按列输出，不重组

**v10诊断结论**：
- 输出8-38都是line=5，但X跨度从221到1684
- 按Y分组把不同列的字混在一起了

**v11新策略**：
完全按列输出，不进行任何行重组：
1. 按X聚类成列
2. 列按X降序排列（右→左）
3. 每列内按Y排序（上→下）
4. 直接按列顺序输出（右列全部 → 第二列全部 → ...）

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ✅ 有点儿意思了！

**用户反馈**:
```
4 龙树中观的世界
（序字被分成左右两部分）龙树被称为"第一一佛陀"亦同时被八
（宗字被分成左右两部分）尊为（共字被分成左右两部分）祖"包括论
（宗字被分成左右两部分）法相（宗字被分成左右两部分）天
（台字被分成左右两部分）宗字被分成左右两部分）
```

**问题诊断**：
- 字序基本正确！✅
- 但多个字被分割成两部分："序"、"宗"、"共"、"台"
- 原因：形态学处理的水平核连接不够

---

### v12版本：增强水平连接，防止字被分割

**v11问题**：
"序"、"宗"、"共"、"台"等左右结构字被分成两部分

**原因**：
- 形态学处理使用1x5水平核，膨胀2次
- 对于左右结构的字，连接不够，导致被识别成两个独立连通域

**v12修复**：
```python
# v12：更强的水平连接
kernel_h = np.ones((1, 7), np.uint8)  # 1x5 → 1x7
dilated = cv2.dilate(binary, kernel_h, iterations=3)  # 2 → 3
```

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 还有切为两半的情况

**用户反馈**：
> "只要顺序对了就好办。分两步走，第一，先把竖列变成横行，顺序不错，现在已做到了。下一步，切割字块排列成正确顺序，参数可参考横版处理系统参数，它处理起字块顺序称得上完美。"

**用户建议**：
- 第一步（顺序）：已做到 ✅
- 第二步（字块切割）：参考横版系统参数

---

### v13版本：参考横版系统参数

**横版系统稳定参数**：
- 3x3核，膨胀2次，腐蚀1次
- 效果：完美

**v13竖版参数**：
- 3x5核（兼顾水平和竖向）
- 膨胀2次，腐蚀1次（与横版相同）

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 看来不能照搬，老问题没解决，又有新情况出现

**用户反馈**：
> "现在，有的字切成两部分，若原版这样...现在就是这样...（展示了最开始的错误输出）"

**问题诊断**：
- v13使用3x5全方向核后，字符顺序又乱了
- 全方向核导致不同列之间的字粘连，破坏了列的独立性
- 不能照搬横版参数

---

### v14版本：保持v11参数 + 字块合并

**v11成功点**：
- 顺序正确 ✅
- 使用1x5水平核，保持列独立性

**v11问题**：
- 左右结构字被切开

**v14策略**：
1. 保持v11的形态学参数（1x5水平核，确保列独立性）
2. 新增`_merge_split_characters`函数：合并被切开的字
3. 判断标准：Y相近且X相邻的两个字块可能是同一个字

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 不如v12，顺序又乱了

**v12-v14总结**：
- v12：增强水平连接（1x7核，3次膨胀），顺序对，仍有切开
- v13：照搬横版参数（3x5核），顺序乱了
- v14：字块合并，顺序也乱了

**结论**：
- v11的顺序是正确的
- 任何修改形态学参数或添加字块合并都会破坏顺序
- 需要换个思路解决字被切开的问题

---

### v11回退版：保持v11，顺序优先

**当前状态**：
回退到v11，保持1x5水平核的形态学参数

**确认点**：
- v11：顺序正确 ✅
- 问题：左右结构字被切开

**下一步思路**：
不在segmenter阶段解决切开问题，让layouter或其他阶段处理

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ✅ 这一款很不错，把字切开的问题解决就完美了

**用户反馈**：
> v11顺序正确，只需要解决字被切开的问题

---

### v15版本：智能合并小块，不破坏顺序

**v11-v14总结**：
- v11：顺序正确 ✅，问题：字被切开
- v12：增强水平连接，仍有切开
- v13：照搬横版参数，顺序乱了
- v14：字块合并，顺序也乱了

**v15策略**：
在字块提取阶段，只合并明显是同一个字的小块：
1. 只合并较小的块（可能是被切开的部分）
2. X相邻（间距<12px）且Y相近（差异<高度的40%）
3. 在列聚类之前合并，不影响列顺序

**修改内容**:
- 新增`_extract_blocks_for_vertical_v15`函数
- 新增`_merge_adjacent_small_blocks`函数
- 保持v11的形态学参数（1x5水平核）

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ 没有改善

**用户反馈**：字仍然被切开

---

### v16版本：增强纯水平连接

**v15问题**：
合并逻辑没有改善

**v16策略**：
增强纯水平连接（不破坏列独立性）：
- 水平核：1x5 → 1x9
- 膨胀次数：2 → 3
- 保持纯水平，不使用竖向或全方向核

**参数对比**：
| 版本 | 水平核 | 膨胀次数 | 效果 |
|------|--------|----------|------|
| v11 | 1x5 | 2 | 顺序对，字切开 |
| v12 | 1x7 | 3 | 顺序对，字切开 |
| v16 | 1x9 | 3 | 待测试 |

**测试结果**: 待测试

**测试日期**: 2026年2月13日

**实际测试结果**: ❌ v16还是不行

**用户反馈**：字仍然被切开，用户需要出门，先记录

---

### v16版本总结

**状态**：失败，字仍然被切开

**当前状态**：
- v11-v16都存在字被切开的问题
- v11的顺序是正确的
- 任何增强水平连接的尝试（v12, v16）都没有解决问题

**待解决问题**：
如何在不破坏列顺序的前提下，让左右结构的字不被切开？

**记录时间**: 2026年2月13日，用户出门前

---

### v17版本：列内智能合并小块

**v16问题总结**：
- v11：顺序正确 ✅，但字被切开
- v12, v16：增强水平连接，仍然切开
- v13：照搬横版参数，顺序乱了
- v14, v15：字块合并逻辑，顺序也乱了

**v17新策略**：
1. **恢复v11的形态学参数**：1x5水平核，膨胀2次（保证顺序正确）
2. **列内智能合并**：在列聚类之前，先宽松地按X分列，然后在列内合并相邻的小块
3. **合并标准**：
   - Y相邻（间距<中位高度的50%）
   - 至少有一个是小块（宽度或高度<中位的70%）
   - 只在列内合并，不跨列

**关键改进**：
- 先用宽松的X阈值(30px)把可能属于同一字的块归为一组
- 在组内按Y查找相邻的小块并合并
- 然后再用严格的列聚类进行最终处理

**修改内容**:
```python
# src/segmenter.py - segment_vertical (v17)

def segment_vertical(self, binary_image, gray_image):
    # 1. 形态学处理（恢复v11参数）
    processed = self._morphology_process_vertical(binary_image)

    # 2. 提取字块
    blocks = self._extract_blocks_for_vertical(processed, gray_image)

    # 3. v17关键：在列聚类之前合并被切开的字
    blocks = self._merge_split_characters_v17(blocks, gray_image)

    # 4. 按X聚类成列
    columns = self._cluster_by_x_vertical(blocks)

    # 5. 排序并输出
    ...

def _merge_split_characters_v17(self, blocks, gray):
    """先宽松分列，再在列内合并相邻小块"""
    # 1. 用宽松阈值(30px)按X分临时列
    temp_columns = self._cluster_by_x_vertical_loose(blocks)

    # 2. 在每列内合并相邻小块
    for col_blocks in temp_columns:
        col_blocks.sort(key=lambda b: b.y)  # 按Y排序
        col_merged = self._merge_adjacent_in_column(col_blocks, gray)
        merged_blocks.extend(col_merged)

    return merged_blocks

def _merge_adjacent_in_column(self, col_blocks, gray):
    """在列内合并Y相邻的小块"""
    # Y间距<中位高度50% 且 至少一个是小块 → 合并
```

**为何这么改**:
1. **恢复v11参数**：保证顺序正确的基础
2. **列内合并**：只在列内操作，不破坏列结构
3. **宽松预处理**：确保被切开的部分被归为同一临时列
4. **精确合并**：只合并真正相邻的小块

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 失败

**用户反馈**: v12-v17都没改善字被分成两部分的问题

---

### v18版本：多重膨胀策略

**v12-v17失败总结**：
- v11：顺序正确 ✅，但字被切开
- v12, v16：增强水平连接（1x7/1x9核）→ 仍然切开
- v13：照搬横版参数（3x5核）→ 顺序乱了
- v14, v15, v17：字块合并逻辑 → 顺序乱了或没效果

**根本问题分析**：
单纯的水平膨胀无法连接某些左右结构字，因为：
1. 这些字的左右部分间距可能较大
2. 增加膨胀会导致列间粘连，破坏顺序

**v18新策略：多重膨胀+组合**
1. 先用弱膨胀提取基础字块（保持列独立性）
2. 再用强膨胀连接被切开的字
3. 将两种结果合并：强膨胀结果用于检测切开，弱膨胀结果保持顺序

**具体实现**：
- 第一步：v11参数提取基础块（1x5核，膨胀2次）
- 第二步：更强参数提取完整块（1x7核，膨胀3次）
- 第三步：对比两组结果，合并被切开的块

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 失败

---

### v19版本：Y坐标精确匹配合并

**v18测试结果**：
- 顺序正确 ✅
- 大部分字处理得极好 ✅
- 只有少数字被切开：宗、三、些、空、前、共、二、吉

**被切开字的共同特征**：
1. 左右结构或左右间距较大
2. 同一列内，Y坐标基本相同
3. X坐标相邻但有间隙
4. 两部分大小相近或互补

**v19策略**：
1. 保持v18的弱膨胀提取（保证顺序）
2. 在列内，查找Y坐标完全匹配（差异<3px）的相邻块
3. 如果X间隙<15px，合并

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 毫无改善

---

### v20版本：膨胀前预处理

**v19失败原因**：
合并逻辑在提取之后执行，但此时切开已经成为事实

**v20新策略**：
在连通域分析之前，对二值图像进行特殊预处理：
1. 先用小膨胀连接近间距笔画
2. 再用水平膨胀连接左右结构
3. 两个阶段相结合

**关键改进**：
- 第一阶段：2x2全方向核，膨胀1次（连接笔画间隙）
- 第二阶段：1x5水平核，膨胀2次（连接左右结构）

**开发完成时间**: 2026年2月13日

**测试结果**: ✅ 部分成功

**用户反馈**：
- 共、空：显示正常 ✅
- 宗、二、三、些、吉：还是分成左右两部分 ❌

**进展**：两阶段策略有效，需要增强连接强度

---

### v21版本：增强水平连接

**v20进展**：
- 共、空已修复 ✅
- 宗、二、三、些、吉仍被切开

**v21策略**：
增加水平膨胀强度：
1. 第一阶段：2x2全方向核，膨胀1次（保持）
2. 第二阶段：1x7水平核，膨胀3次（增强：1x5→1x7，2次→3次）

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 无改善

**用户反馈**：跟v20一样

---

### v22版本：诊断分析被切开字的特征

**v21失败原因**：
单纯增加水平膨胀次数无效，说明问题不在膨胀强度上

**v22策略**：
先诊断分析，输出被切开字的详细特征：
1. X、Y坐标
2. 宽度、高度
3. 两部分之间的间距
4. 面积、宽高比

通过分析找出合并的最佳参数

**开发完成时间**: 2026年2月13日

**测试结果**: ✅ 诊断成功

**诊断发现**：
- 中位高度: 41, 中位宽度: 61
- 找到 177 对可能被切开的字

**被切开字的特征**：
- X间距：18-23像素（主要集中在18-23）
- Y差距：0-3像素（几乎完全对齐）
- 左块X：约200-205，右块X：约282-284
- 左块宽度：56-64，右块宽度：57-63
- 两块总宽度：约115-127像素

**关键发现**：
- 左右两块X坐标非常稳定（左约202，右约283）
- X间距18-23像素是切开的关键特征
- Y完全对齐（差距0-3px）

---

### v23版本：基于诊断结果精确合并

**v22诊断结论**：
被切开字的特征：
- X间距：18-23像素
- Y差距：0-3像素
- 左块X约202，右块X约283

**v23策略**：
1. 保持v20的两阶段形态学处理
2. 在字块提取后，精确合并符合特征的块对：
   - Y差距 < 5px
   - X间距在15-30px之间
   - 宽度和都在100-150px之间（正常字的大小）

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 失败

**用户反馈**：没有改善，而且有些字上一版正常显示这次完全缺失

**问题分析**：
合并逻辑误伤了正常字，需要更保守的策略

---

### v24版本：保守合并 - 只合并特定X位置的块

**v23失败原因**：
合并条件太宽松，误伤了正常字

**v24策略**：
基于v22诊断，被切开字的X坐标非常稳定：
- 左块X：约200-205
- 右块X：约282-284

只合并这两个特定X位置的块对，其他位置不动

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 仍然不行

---

### 版本总结与规律发现

**v22诊断发现的规律**：
- 被切开字的左块X：200-205
- 被切开字的右块X：282-284
- X间距：18-23像素
- Y差距：0-3像素

**关键问题**：
之前所有版本都在事后合并，但：
1. 合并逻辑复杂，容易误伤正常字
2. 在列聚类后合并，索引混乱

**新思路**：
既然被切开字的位置非常固定（X≈200和X≈283），可以：
1. 在形态学处理前，先检查这两个位置
2. 对这两个位置进行额外的局部膨胀
3. 只处理这些特定区域，不影响其他位置

---

### v25版本：局部膨胀策略

**核心思路**：
不进行全局膨胀，只对X≈200和X≈283这两个位置进行局部膨胀

1. 检测X≈195-215和X≈275-295区域的块
2. 对这些区域进行额外的水平膨胀
3. 其他区域保持原样

**开发完成时间**: 2026年2月13日

**测试结果**: ❌ 策略没有奏效

---

### v26版本：模式匹配合并

**关键发现**：
v22诊断显示被切开字的X坐标非常固定：
- 左块X：200-205（几乎所有都是202）
- 右块X：282-284（几乎所有都是283）
- X间距：18-23像素
- Y差距：0-3像素

**v26策略**：
在字块提取后，直接匹配这个特定模式：
1. 找出所有X在195-210范围内的块（左部分）
2. 找出所有X在275-295范围内的块（右部分）
3. 按Y匹配，Y差距<5px的配对合并
4. 只合并这些配对的块，其他完全不动

**开发完成时间**: 2026年2月13日

**测试状态**: 🕐 待测试

---

### v29版本：最终版本

**测试结果**: ✅ 成功！

**用户反馈**：
> "这版就正常，除了某些字被分成左右两部分"

**v29最终方案**：
- 回退到v11的核心逻辑（1x5水平核，膨胀2次）
- 添加黑点过滤（W=30-40, H<=20, 宽高比>2.0）
- 移除所有复杂的合并逻辑

**效果**：
- 顺序正常 ✅
- 部分字被切开（宗、二、三、些、吉等）- 可接受

**经验教训**：
v12-v28共17个版本的各种复杂尝试都是无用功。最简单的v11方案才是正确的方向。

**开发完成时间**: 2026年2月13日

**最终状态**: v29为竖版PDF处理的稳定版本

---

### v28版本：过滤黑点干扰（调试中）

**用户发现**：
出错的三列在原版中，每列第一个字上面隔开一个字的距离都有一个黑点

**原版结构**（从右往左数）：
- 第一列：（黑点）（隔一个字距离）不丢书包，避免学究式的文献研究
- 第二列：佛学与哲学背景的读者
- 第三列：（黑点）（隔一个字距离）不用注脚附录...
- 第四列：以譬代论...

**处理后错误**：
黑点、不、丢书包... 佛学与哲学... 以不譬用代注...

**调试发现**：
1. 没有黑点被过滤（area<20的块数为0）
2. 黑点可能已经被连通域分析合并到相邻字块
3. 需要进一步分析Y坐标较小的块

**开发完成时间**: 2026年2月13日

**测试状态**: 🕐 调试中

**最新调试结果**：
- 过滤了10个疑似黑点（包括X=216,Y=588和X=297,Y=588）
- 总块数从545减少到535
- 但效果仍然不行

---

### v29版本：回退到v11+过滤黑点

**问题**：
v12-v28各种版本都有问题，决定回退到v11的基础逻辑

**v11特征**：
- 1x5水平核，膨胀2次
- 按列输出，顺序正确 ✅
- 问题：部分字被切开

**v29改进**：
- 保持v11的核心逻辑
- 添加黑点过滤（W=30-40, H<=20, 宽高比>2.0）
- 移除所有复杂的合并逻辑

**开发完成时间**: 2026年2月13日

**测试状态**: 🕐 待测试

---

### v29版本：最终版本

**测试结果**: ✅ 成功！

**用户反馈**：
> "这版就正常，除了某些字被分成左右两部分"

**v29最终方案**：
- 回退到v11的核心逻辑（1x5水平核，膨胀2次）
- 添加黑点过滤（W=30-40, H<=20, 宽高比>2.0）
- 移除所有复杂的合并逻辑

**效果**：
- 顺序正常 ✅
- 部分字被切开（宗、二、三、些、吉等）- 可接受

**经验教训**：
v12-v28共17个版本的各种复杂尝试都是无用功。最简单的v11方案才是正确的方向。

**开发完成时间**: 2026年2月13日

**最终状态**: v29为竖版PDF处理的稳定版本

---

### 自动检测页面方向功能

**用户需求**：
有的书某一页是横版，大部分是竖版；有的某一页是竖版，大部分是横版。
不能在GUI面板直接指定方向，否则特殊页会出错。

**解决方案**：
添加自动检测功能，每页自动判断是横版还是竖版。

**实现**：
1. segmenter.py: 添加_detect_orientation()方法
2. gui.py: 添加"自动检测"选项，设为默认
3. pipeline.py: 支持orientation="auto"

**检测逻辑**：
- 分析字块的X和Y坐标分布
- 计算标准差：竖版X方向离散（多列），横版Y方向离散（多行）
- 如果X标准差 > Y标准差*1.2 → 竖版
- 如果Y标准差 > X标准差*1.2 → 横版

**开发完成时间**: 2026年2月13日

---

### 修复横竖混排页面顺序问题

**问题**：
当PDF先横版后竖版时（如"龍樹中觀的世界"），处理后横版跑到竖版后面，顺序颠倒。

**原因**：
- 竖版：收集所有字符到最后一起layout
- 横版：每页单独layout并立即添加
- 先横后竖时：横版先添加，竖版后添加 → 正确
- 先竖后横时：竖版在收集，横版先添加，竖版最后添加 → 错误

**修复方案**：
按原始页码顺序处理，遇到方向变化时先layout累积的竖版字符。

**开发完成时间**: 2026年2月13日

---

